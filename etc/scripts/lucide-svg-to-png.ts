import * as fs from "node:fs/promises";
import * as path from "node:path";
const sharp: typeof import("sharp") = require("sharp");

type Config = {
  group: string;
  baseSize?: number;
  package?: string;
  prefix?: string;
  icons: string[];
  outDir?: string;
  genFile?: string;
  assetDir?: string;
};

function parseArgs() {
  const i = process.argv.indexOf("--config");
  if (i === -1 || !process.argv[i + 1]) {
    console.error(
      "Usage: tsx etc/scripts/lucide-svg-to-png.ts --config config/icons.json",
    );
    process.exit(1);
  }
  return { configPath: process.argv[i + 1] };
}

async function readConfig(p: string): Promise<Config> {
  const cfg = JSON.parse(await fs.readFile(p, "utf8")) as Config;
  if (!cfg.group) throw new Error("config.group is required");
  if (!cfg.icons?.length) throw new Error("config.icons must be non-empty");
  return {
    baseSize: 24,
    package: "lucide-static",
    prefix: "",
    outDir: "app/assets/icons",
    genFile: "app/assets/icons/index.generated.ts",
    assetDir: `assets/icons/${cfg.group}`,
    ...cfg,
  };
}

function svgPathForIcon(pkg: string, name: string, prefix?: string) {
  const rel = prefix ? `icons/${prefix}/${name}.svg` : `icons/${name}.svg`;
  return require.resolve(`${pkg}/${rel}`);
}

async function ensureDir(dir: string) {
  await fs.mkdir(dir, { recursive: true });
}

async function buildPngs(cfg: Config) {
  const assetDir = path.resolve(cfg.assetDir!);
  await ensureDir(assetDir);

  for (const name of cfg.icons) {
    const svg = await fs.readFile(
      svgPathForIcon(cfg.package!, name, cfg.prefix),
    );
    const one = cfg.baseSize!;
    await sharp(svg).resize(one).png().toFile(
      path.join(assetDir, `${name}.png`),
    );
    await sharp(svg).resize(one * 2).png().toFile(
      path.join(assetDir, `${name}@2x.png`),
    );
    await sharp(svg).resize(one * 3).png().toFile(
      path.join(assetDir, `${name}@3x.png`),
    );
  }
  return assetDir;
}

function generateIndexTs(cfg: Config, assetDirAbs: string) {
  const genFileAbs = path.resolve(cfg.genFile!);
  const genDir = path.dirname(genFileAbs);
  const rel = (p: string) => {
    const rp = path.relative(genDir, p).replace(/\\/g, "/");
    return rp.startsWith(".") ? rp : `./${rp}`;
  };

  const lines: string[] = [];
  lines.push("// AUTO-GENERATED. Do not edit.");
  lines.push("// Generated by etc/scripts/lucide-svg-to-png.ts");
  lines.push("");
  lines.push("/* eslint-disable @typescript-eslint/no-var-requires */");
  lines.push("export const assetsMap = {");
  for (const name of cfg.icons) {
    const p1 = rel(path.join(assetDirAbs, `${name}.png`));
    lines.push(`  "${name}": require("${p1}"),`);
  }
  lines.push("} as const;");
  lines.push("export type IconKey = keyof typeof assetsMap;");
  lines.push("");

  return { file: genFileAbs, code: lines.join("\n") };
}

async function main() {
  const { configPath } = parseArgs();
  const cfg = await readConfig(configPath);
  const outDirAbs = await buildPngs(cfg);

  const { file, code } = generateIndexTs(cfg, outDirAbs);
  await ensureDir(path.dirname(file));
  await fs.writeFile(file, code, "utf8");

  console.log(
    `✅ Exported ${cfg.icons.length} icons → ${path.resolve(cfg.outDir!)}`,
  );
  console.log(`✅ Generated mapping → ${path.resolve(cfg.genFile!)}`);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
